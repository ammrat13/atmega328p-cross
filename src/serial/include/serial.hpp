#pragma once

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>


/**
 * Code for dealing with USART Serial IO
 *
 * It has classes to abstract away the MMIO needed for serial access, as well as
 * declarations for all the serial ports present on the platform.
 */
namespace USART {


/**
 * Encapsulates a USART's configuration
 *
 * Before use, a USART must be configured. The user must specify things like
 * whether to send or recieve, whether and which parity to use, and the
 * baud-rate with 2X if needed. This library does not allow the user to
 * configure the number of bits to work with - it's always 8-bit.
 */
struct Configuration {

    /** Baud-rate register value */
    // This must be specified first since C++ struct fields can't be reordered
    unsigned baudrate_register : 12;

    /** Whether to use 2X mode for the baud-rate */
    bool use_2X : 1;

    /** Whether to enable the reciever */
    bool rx_en : 1;
    /** Whether to enable the transmitter */
    bool tx_en : 1;

    /** Possible settings for the number of stop bits to use */
    enum StopBits : bool {
        ONE = 0,
        TWO = 1,
    };
    /** Whether to use one or two stop bits */
    StopBits stop_bits : 1;

    /** Possible settings for the parity bits to use */
    enum Parity : uint8_t {
        NONE = 0, /** No parity */
        EVEN = 2, /** Even parity */
        ODD = 3,  /** Odd parity */
    };
    /** Setting for parity */
    Parity parity : 2;

    /**
     * Startup configuration of USARTS
     *
     * On boot, hardware serial ports are configured in a certain way. This
     * field is that configuration.
     */
    static const Configuration STARTUP;
}; // struct Settings


/**
 * Structure to report errors USART operations
 *
 * Serial transmission can fail. For instance, there could be a parity error or
 * a data overrun. This structure serves to report on those errors.
 *
 * If no error is present, there's a special value for that: `NONE`. It's set
 * equal to zero. Other than that, there are other flags for an error - they can
 * be bitwise-ORed together.
 *
 * Most of the flags come from the hardware error registers. However, `DISABLED`
 * is generated by the software. It is raised when a function that needs to
 * receive or transmit is called when that functionality is disabled.
 */
enum Error : uint8_t {
    NONE = 0,     /** Indicates success */
    PARITY = 1,   /** Parity error from `UPEn` */
    OVERRUN = 2,  /** Data overrun from `DORn` */
    FRAME = 4,    /** Frame error from `FEn` */
    DISABLED = 8, /** Required functionality is disabled by the configuration */
}; // enum Error

/** Bitwise AND for the error type */
Error operator&(const Error lhs, const Error rhs);
/** Bitwise AND assignment for the error type */
Error& operator&=(Error &lhs, const Error rhs);
/** Bitwise OR for the error type */
Error operator|(const Error lhs, const Error rhs);
/** Bitwise OR assignment for the error type */
Error& operator|=(Error &lhs, const Error rhs);


/**
 * USART interface on an AVR platform
 *
 * This class abstracts the MMIO interface for USARTs. It deals with hardware
 * registers internally, but provides a C++ abstraction.
 *
 * It should be instantiated statically, with one instance for each hardware
 * serial interface.
 *
 * Most Atmel chips have a "standard" interface for a USART, and this class
 * assumes it. The interface is, in order:
 *   - 1-byte Configuration Register A
 *   - 1-byte Configuration Register B
 *   - 1-byte Configuration Register C
 *   - 1-byte Reserved Space
 *   - 2-byte Baud-rate Registers (little-endian)
 *   - 1-byte Data Register
 *
 * The base address the constructor takes is that of Configuration Register A.
 */
class USART {

public:

    /**
     * Base address of the USART component
     *
     * The addresses of all the other registers are calculated by adding their
     * offset to this.
     */
    const uintptr_t base_address;

    /**
     * Construct a USART object
     *
     * This should only really be done at the start of the program. It takes in
     * a base address, which must correspond to a hardware serial port. The
     * configuration is set to what it would be on bootup.
     *
     * @param [in] base The base address of the USART
     */
    USART(uintptr_t base);

    /**
     * Configure the USART based on the configuration given
     *
     * This will modify hardware registers to bring them in line with the
     * configuration given. It will also enable the USART if that option was
     * given.
     *
     * This must be done before using the USART, otherwise the default state of
     * the registers will be used. Additionally, this function will completely
     * disable the USART before reenabling it, and it will flush all the buffers
     * in the process.
     *
     * @param [in] config How to configure the serial port
     */
    void setConfiguration(const Configuration &config);
    /**
     * Retrieve the current configuration of the USART
     *
     * This will read the hardware registers set by `setConfiguration` and place
     * them into a `Configuration` object. The state of the registers will not
     * be changed.
     *
     * @return How the port is configured
     */
    Configuration getConfiguration() const;
    /**
     * Get the error flags currently set in the USART
     *
     * Read from the hardware registers to get this information. It will not
     * modify the registers, just read them. Note however that reading from the
     * USART will destroy these error flags.
     *
     * @return The current error flags set
     */
    Error getError() const;

    /**
     * Put a character onto the USART
     * @param [in] c The character to put
     * @return `Error::DISABLED` if the USART's transmitter is disabled, and
     *         `Error::NONE` otherwise
     */
    Error putc(uint8_t c);
    /**
     * Put `len` bytes from `buf` onto the USART
     * @param [in] buf The bytes to put
     * @param [in] len How many bytes to put
     * @return `Error::DISABLED` if the USART's transmitter is disabled, and
     *         `Error::NONE` otherwise
     * @see putc
     */
    Error putn(const uint8_t *buf, size_t len);
    /**
     * Put a null-terminated string onto the USART
     * @param [in] buf The string to put
     * @return `Error::DISABLED` if the USART's transmitter is disabled, and
     *         `Error::NONE` otherwise
     * @see putc
     */
    Error puts(const char *buf);

    /**
     * Get a character from the USART
     * @param [out] c The character received
     * @return Any errors
     */
    Error getc(uint8_t &c);
    /**
     * Get up to `len` characters from the USART
     *
     * It'll read until the first error, at which point it returns. The number
     * of bytes read is returned as well.
     *
     * @param [in] buf The buffer to read into
     * @param [in] len How many bytes to try to read
     * @param [out] read How many bytes were actually read
     * @return The error encountered when reading stopped
     * @see getc
     */
    Error getn(uint8_t *buf, size_t len, size_t &read);
    /**
     * Read up to `len` characters from the USART until the character `until`
     *
     * It'll read until it either encounters an error or until it hits the
     * character specified by `until`. The number of bytes read is put in
     * `read`. Note that the terminating `until` character is included in this
     * count and in the final string.
     *
     * The parameter `len` indicates the length of the buffer, including the
     * null terminator. A null terminator is automatically placed after `read`
     * regardless of the reason of termination. Thus, `read` will be at most
     * `len-1`.
     *
     * @param [in] buf The buffer to read into
     * @param [in] len How many bytes to try to read
     * @param [out] read How many bytes were actually read
     * @param [in] until The character to read until
     * @return The error encountered when reading stopped
     * @see getc
     */
    Error gets(char *buf, size_t len, size_t &read, char until);

    /**
     * Flush the receive buffer and drop the data in it
     *
     * This function will essentially turn the receive functionality off and on
     * again, clearing all the data in the queue.
     */
    void flushRX();
    // It doesn't make much sense to have a `flushTX`. It would require reading
    // the TXCn bit of the serial port, with the program spinlocking if nothing
    // was put to send before flushing. Also, there's a race condition with
    // setting the bit before sending the data.

private:

    /** Offset to the A configuration register */
    static constexpr size_t UCSRnA_OFFSET = 0x0;
    /** Offset to the B configuration register */
    static constexpr size_t UCSRnB_OFFSET = 0x1;
    /** Offset to the C configuration register */
    static constexpr size_t UCSRnC_OFFSET = 0x2;

    /** Offset to the baud-rate register */
    static constexpr size_t UBRRn_OFFSET = 0x4;
    /** Offset to the data register */
    static constexpr size_t UDRn_OFFSET = 0x6;

    /**
     * Holds the current configuration of the USART
     *
     * We cache the configuration instead of reading from hardware registers
     * every time. It saves a lot of time, especially in `putc` which is usually
     * called in a tight loop. There is data redundancy though.
     */
    Configuration configuration;
}; // class USART


/**
 * Number of hardware serial ports
 *
 * This number varies from platform to platform. The code uses the
 * `__AVR_Device__` macros to determine the correct value.
 */
#ifdef __DOXYGEN__
    constexpr size_t NUM_PORTS;
#elif __AVR_ATmega328P__
    constexpr size_t NUM_PORTS = 1;
#else
    #error LibSerial does not support this platform
#endif

/**
 * Array of hardware serial ports
 *
 * This array has `NUM_PORTS` entries, one for each hardware serial interface.
 * The contents change depending on the platform.
 *
 * @see NUM_SERIAL
 */
extern USART PORT[NUM_PORTS];


}; // namespace USART
